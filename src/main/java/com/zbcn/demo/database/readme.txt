在分库分表之后你必然要面对的一个问题，就是id咋生成？

因为要是一个表分成多个表之后，每个表的id都是从1开始累加自增长，那肯定不对啊。

举个例子，你的订单表拆分为了1024张订单表，每个表的id都从1开始累加，这个肯定有问题了！

你的系统就没办法根据表主键来查询订单了，比如id = 50这个订单，在每个表里都有！

所以此时就需要分布式架构下的全局唯一id生成的方案了，在分库分表之后，对于插入数据库中的核心id，不能直接简单使用表自增id，要全局生成唯一id，然后插入各个表中，保证每个表内的某个id，全局唯一。

比如说订单表虽然拆分为了1024张表，但是id = 50这个订单，只会存在于一个表里。

那么如何实现全局唯一id呢？有以下几种方案。


（1）方案一：独立数据库自增id

这个方案就是说你的系统每次要生成一个id，都是往一个独立库的一个独立表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个id。拿到这个id之后再往对应的分库分表里去写入。

比如说你有一个auto_id库，里面就一个表，叫做auto_id表，有一个id是自增长的。

那么你每次要获取一个全局唯一id，直接往这个表里插入一条记录，获取一个全局唯一id即可，然后这个全局唯一id就可以插入订单的分库分表中。

这个方案的好处就是方便简单，谁都会用。缺点就是单库生成自增id，要是高并发的话，就会有瓶颈的，因为auto_id库要是承载个每秒几万并发，肯定是不现实的了。



（2）方案二：uuid

这个每个人都应该知道吧，就是用UUID生成一个全局唯一的id。

好处就是每个系统本地生成，不要基于数据库来了

不好之处就是，uuid太长了，作为主键性能太差了，不适合用于主键。

如果你是要随机生成个什么文件名了，编号之类的，你可以用uuid，但是作为主键是不能用uuid的。



（3）方案三：获取系统当前时间

这个方案的意思就是获取当前时间作为全局唯一的id。

但是问题是，并发很高的时候，比如一秒并发几千，会有重复的情况，这个是肯定不合适的。

一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个id，如果业务上你觉得可以接受，那么也是可以的。

你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号，比如说订单编号：时间戳 + 用户id + 业务含义编码。




（4）方案四：snowflake算法的思想分析

snowflake算法，是twitter开源的分布式id生成算法。

其核心思想就是：使用一个64 bit的long型的数字作为全局唯一id，这64个bit中，其中1个bit是不用的，然后用其中的41 bit作为毫秒数，用10 bit作为工作机器id，12 bit作为序列号。

给大家举个例子吧，比如下面那个64 bit的long型数字，大家看看



上面第一个部分，是1个bit：0，这个是无意义的

上面第二个部分是41个bit：表示的是时间戳

上面第三个部分是5个bit：表示的是机房id，10001

上面第四个部分是5个bit：表示的是机器id，1 1001

上面第五个部分是12个bit：表示的序号，就是某个机房某台机器上这一毫秒内同时生成的id的序号，0000 00000000

1 bit：是不用的，为啥呢？

 因为二进制里第一个bit为如果是1，那么都是负数，但是我们生成的id都是正数，所以第一个bit统一都是0


41 bit：表示的是时间戳，单位是毫秒。

 41 bit可以表示的数字多达2^41 - 1，也就是可以标识2 ^ 41 - 1个毫秒值，换算成年就是表示69年的时间。


10 bit：记录工作机器id，代表的是这个服务最多可以部署在2^10台机器上，也就是1024台机器。

  但是10 bit里5个bit代表机房id，5个bit代表机器id。意思就是最多代表2 ^ 5个机房（32个机房），每个机房里可以代表2 ^ 5个机器（32台机器）。


12 bit：这个是用来记录同一个毫秒内产生的不同id。

  12 bit可以代表的最大正整数是2 ^ 12 - 1 = 4096，也就是说可以用这个12bit代表的数字来区分同一个毫秒内的4096个不同的id

简单来说，你的某个服务假设要生成一个全局唯一id，那么就可以发送一个请求给部署了snowflake算法的系统，由这个snowflake算法系统来生成唯一id。

这个snowflake算法系统首先肯定是知道自己所在的机房和机器的，比如机房id = 17，机器id = 12。

接着snowflake算法系统接收到这个请求之后，首先就会用二进制位运算的方式生成一个64 bit的long型id，64个bit中的第一个bit是无意义的。

接着41个bit，就可以用当前时间戳（单位到毫秒），然后接着5个bit设置上这个机房id，还有5个bit设置上机器id。

最后再判断一下，当前这台机房的这台机器上这一毫秒内，这是第几个请求，给这次生成id的请求累加一个序号，作为最后的12个bit。

最终一个64个bit的id就出来了，类似于：



这个算法可以保证说，一个机房的一台机器上，在同一毫秒内，生成了一个唯一的id。可能一个毫秒内会生成多个id，但是有最后12个bit的序号来区分开来。

下面我们简单看看这个snowflake算法的一个代码实现，这就是个示例，大家如果理解了这个意思之后，以后可以自己尝试改造这个算法。

总之就是用一个64bit的数字中各个bit位来设置不同的标志位，区分每一个id。