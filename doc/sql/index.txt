查看索引: show index from user

主键索引: primary_key  特殊的唯一索引，不允许有空值，一般是创建表的时候一起创建。注意：一个表只有一个主键。

唯一索引： UNIQUE  唯一索引的列必须是唯一值。但允许有空值，如果是组合索引，则列值得组合必须唯一
      创建方式：ALTER TABLE table_name ADD UNIQUE (column)

唯一组合索引 UNIQUE：
      创建方式：ALTER TABLE table_name ADD UNIQUE index_column1_column2 (column1,column2) 

普通索引 INDEX : 这是最基本的索引，他没有任何限制。
      创建方式：ALTER TABLE table_name ADD INDEX index_name (column_name)

组合索引 INDEX : 即一个索引包含多列。多用于回表查询。
      创建方式： ALTER TABLE table_name ADD INDEX index_name (column1,column2,column3 ....)

全文索引 FULLTEXT :全文检索，是目前搜索引擎使用的一种关键技术。
      创建方式：ALTER TABLE table_name ADD FULLTEXT (column)

删除索引：索引一经创建，就不能修改，只能删除后重建。
    删除索引方式：DROP INDEX index_name ON table_name;

索引设计原则：
  1）适合索引的列是出现在where子句中的列，或者连接子句中指定的列
  2）基数较小的类，索引效果较差，没有必要在此列建立索引；
  3）使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间；
  4）不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。（在做查询频繁的字段上建立索引即可）

MySQL索引优化实战：
      查看表的数据结构：DESC table_name

索引相关的重要概念: 
  1. 基数：单个列唯一键（distict_keys）的数量叫做基数。
    查看基数的语法：SELECT COUNT(DISTINCT name),COUNT(DISTINCT gender) FROM user;

  2. 回表：当对一个列创建索引之后，索引会包含该列的键值及键值对应行所在的rowid。通过索引中记录的rowid访问表中的数据就叫回表。回表次数太多会严重影响SQL性能，如果回表次数太多，就不应该走索引扫描，应该直接走全表扫描。
    说明：EXPLAIN命令结果中的Using Index意味着不会回表，通过索引就可以获得主要的数据。Using Where则意味着需要回表取数据

索引优化实战
  查看索引使用情况：SHOW STATUS LIKE 'Handler_read%'

    分析：1》Handler_read_key：如果索引正在工作，Handler_read_key的值将很高。
         2》Handler_read_rnd_next：数据文件中读取下一行的请求数，如果正在进行大量的表扫描，值将较高，则说明索引利用不理想。

    索引优化规则：
       1）如果MySQL估计使用索引比全表扫描还慢，则不会使用索引。
         返回数据的比例是重要的指标，比例越低越容易命中索引。记住这个范围值——30%，后面所讲的内容都是建立在返回数据的比例在30%以内的基础上。
       2）前导模糊查询不能命中索引。非前导模糊查询则可以使用索引
       3）数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来。
       4）复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中符合索引
       5）union、in、or都能够命中索引，建议使用in。 查询的CPU消耗：or>in>union。
       6）用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到。
          分析：因为or后面的条件列中没有索引，那么后面的查询肯定要走全表扫描，在存在全表扫描的情况下，就没有必要多一次索引扫描增加IO访问。
      7）负向条件查询不能使用索引，可以优化为in查询。负向条件有：!=、<>、not in、not exists、not like等。
      8）范围条件查询可以命中索引。范围条件有：<、<=、>、>=、between等。
      9）数据库执行计算不会命中索引。
      10）利用覆盖索引进行查询，避免回表。
      11）建立索引的列，不允许为null

      12） 更新十分频繁的字段上不宜建立索引：因为更新操作会变更B+树，重建索引。这个过程是十分消耗数据库性能的。
      13） 区分度不大的字段上不宜建立索引：类似于性别这种区分度不大的字段，建立索引的意义不大。因为不能有效过滤数据，性能和全表扫描相当。另外返回数据的比例在30%以外的情况下，优化器不会选择使用索引。
      14） 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。虽然唯一索引会影响insert速度，但是对于查询的速度提升是非常明显的。另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，在并发的情况下，依然有脏数据产生。

      15）多表关联时，要保证关联字段上一定有索引。

      16） 创建索引时避免以下错误观念：索引越多越好，认为一个查询就需要建一个索引；宁缺勿滥，认为索引会消耗空间、严重拖慢更新和新增速度；抵制唯一索引，认为业务的唯一性一律需要在应用层通过“先查后插”方式解决；过早优化，在不了解系统的情况下就开始优化。





